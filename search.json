[{"title":"利用Kiro反代薅羊毛","path":"/2026/01/17/利用Kiro反代薅羊毛/","content":"AWS 为了吸引用户注册自己的 Kiro 平台，用自己企业内部署的 ClaudeCode 来当福利，可以使用满血的 Opus，给每个新注册用户都分配了 500 积分，每个月还有 50 的免费额度，换算下来 2 积分相当于 1 美元，那不狠狠撸一下？ 一、部署反代服务当然，首先得有自己的服务器，直接按照官方教程部署 AIClient-2-API 。 1docker run -d -p 3000:3000 -p 8085-8087:8085-8087 -p 19876-19880:19876-19880 --restart=always -v &quot;指定路径:/app/configs&quot; --name aiclient2api justlikemaki/aiclient-2-api 部署好了以后，进服务器链接访问一下， 1http://（你的IP你的IP你的IP你的IP）:3000/ 看到这个说明成功了，默认初始密码是 admin123 当然，得改一下。 二、注册 Kiro 账号先启动无痕模式 点生成授权 点击 在蹦出来的弹窗里，用邮箱注册 AWS Builder ID，注意不要使用临时邮箱。 底下就会追加，把不健康的删掉就行。 三、配置 ClaudeCode首先得安装本地的 CC 依赖。 12npm install -g @anthropic-ai/claude-codeclaude --version 安装完了以后，找到 C:\\Users\\&#123;你的用户名&#125;\\.claude ，新建一个 settings.json ，输入以下内容。（注意把服务器地址和key改成自己的） 123456789101112131415&#123; &quot;env&quot;: &#123; &quot;ANTHROPIC_AUTH_TOKEN&quot;: &quot;TOKENTOKENTOKENTOKENTOKENTOKENTOKENTOKENTOKENTOKENTOKENTOKENTOKEN&quot;, &quot;ANTHROPIC_BASE_URL&quot;: &quot;http://（你的IP你的IP你的IP）:3000/claude-kiro-oauth&quot;, &quot;ANTHROPIC_DEFAULT_HAIKU_MODEL&quot;: &quot;claude-opus-4-5-20251101&quot;, &quot;ANTHROPIC_DEFAULT_OPUS_MODEL&quot;: &quot;claude-opus-4-5-20251101&quot;, &quot;ANTHROPIC_DEFAULT_SONNET_MODEL&quot;: &quot;claude-opus-4-5-20251101&quot;, &quot;ANTHROPIC_DEFAULT_MODEL&quot;: &quot;claude-opus-4-5-20251101&quot;, &quot;CLAUDE_CODE_DISABLE_NONESSENTIAL_TRAFFIC&quot;: 1 &#125;, &quot;permissions&quot;: &#123; &quot;allow&quot;: [], &quot;deny&quot;: [] &#125;&#125; 如果不知道 token 填什么的话，返回你的后台，看到这里，这里就是，填进去就行。 cmd 测试一下，毛问题没有。 vsc 也试一下，完全没问题。 四、多薅几个重复 步骤二 即可，要注意的是每次注册新账号，都记得一定要重新打开新无痕模式。","tags":["Linux","AI"],"categories":["开发日常"]},{"title":"QQ机器人--2RSS订阅","path":"/2025/12/25/QQ机器人--2RSS订阅/","content":"身为一个群组机器人，怎么能没有消息推送？所以针对不同的群组肯定要订阅不同的消息，好在 koishi 是有现成的 RSS 订阅消息插件的，可以省下很多功夫。 一、追加 RSS 订阅插件直接搜索 RSS，有一个 rss-owl 的插件，直接下载。 追加然后去启动，启动好了以后，会发现它有默认的 RSS 订阅地址，但是用的人很多，基本上用不了，所以需要自己搭建一个。 二、自建 RSSHub公共实例不稳定&#x2F;限流是常态，尤其是 B 站相关路由。你要稳定订阅，最靠谱就是自建 RSSHub，并给它配 puppeteer（browserless，无头浏览器）。由于自己在搭建 napcat 和 koishi 的时候本身就使用的 Docker ，所以直接在 docker-compose.yml 里追加两个服务就行： 1234567891011121314151617181920212223.... # 服务3: RSSHub rsshub: image: diygod/rsshub:latest container_name: rsshub restart: always environment: - TZ=Asia/Shanghai # 让 RSSHub 使用 browserless 提供的 Chrome（bilibili 动态路由经常需要） - PUPPETEER_WS_ENDPOINT=ws://browserless:3000 ports: # 只绑定到本机，避免对公网暴露（Koishi 走内网 http://rsshub:1200 访问） - &quot;127.0.0.1:1200:1200&quot; depends_on: - browserless # 服务4: browserless browserless: image: browserless/chrome:latest container_name: browserless restart: always environment: - TZ=Asia/Shanghai 然后重启容器， 1docker compose up -d 成功后直接在本地确认是否可用， 1curl -I &quot;http://127.0.0.1:1200/healthz&quot; 切换到 koishi 容器里，确认是否能内网访问， 1234docker exec -it koishi shcurl -I &quot;http://rsshub:1200/healthz&quot;curl -L -I &quot;http://rsshub:1200/bilibili/user/dynamic/598504181&quot; 在对应的 QQ 群里追加订阅，（需要注意的是，私聊是没有用的，必须在群里测试） 1rss http://rsshub:1200/bilibili/user/dynamic/598504181 -t 鹰角网络B站动态 -i content 测试一下，能正常出结果，就成功了。 1rss -l 关于插件设置中的仓库，请参考 koishi-plugin-rss-owl 三、容易遇到的问题如果你的机器人加了多个群，且多个群有相同的推送，经常会出现无法推送的情况，错误形如以下： 12345672025-12-25 09:47:08 [W] bot Error: Timeout with request send_group_forward_msg, args: &#123;&quot;group_id&quot;:XXXXXXXXX,&quot;messages&quot;:[&#123;&quot;type&quot;:&quot;node&quot;,&quot;data&quot;:&#123;&quot;name&quot;:&quot;XXXXXXX&quot;,&quot;uin&quot;:&quot;XXXXXX&quot;,&quot;content&quot;:[&#123;&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:&#123;&quot;text&quot;:&quot;《「星语共愿」特别纪念PV》 「星语共愿」特别纪念PV承载无数心意的今天，繁星与我们一 ...\tat Timeout._onTimeout (/koishi/node_modules/koishi-plugin-adapter-onebot/lib/index.js:676:16)\tat listOnTimeout (node:internal/timers:581:17)\tat process.processTimers (node:internal/timers:519:7) 先创建默认的 cache 目录存放缓存图片，否则后续操作会报错， 1docker exec -it koishi sh -lc &#x27;mkdir -p /koishi/data/cache/rssOwl &amp;&amp; ls -al /koishi/data/cache&#x27; 修改容器文件配置，让 napcat 也能共享缓存 12345napcat: volumes: - ./napcat/data:/app/.config/QQ - ./napcat/config:/app/napcat/config - ./koishi/data/cache/rssOwl:/koishi/data/cache/rssOwl:ro 这三个位置改成所展示的这样， 再重启容器, 1docker compose up -d 就能杜绝绝大部分问题，BASE64 的图片消息会导致 log 过长，本身也不适合 Debug ，还是改过来比较好。 四、账号提权对于 RSS 命令，默认只能在群里执行，如果没配权限的话，那就会变成所有人都能随意添加订阅链接，故需要指定高权限账号，不过不推荐给自己过高的权限，一切危险操作都只在 Web 后台里执行最佳，给自己一个 2 的权限就行。 首先找到数据库，然后找到 binding ，pid 是自己的 QQ 账号，找到自己那条，然后看 aid，比如我这里是 1。 找到以后，去看 user 表，找到 id 为 1 的账号，然后手动把 authority 改为你想要的权限，我这里直接设置为了 2，记得点击应用操作。 插件和写 SQL 都太麻烦，这样反而容易点。","tags":["QQ机器人","Linux","napcat","koishi"],"categories":["开发日常"]},{"title":"QQ机器人--1环境准备","path":"/2025/12/04/QQ机器人--1环境准备/","content":"使用 Napcat + Koishi 的组合创建一个QQ机器人的大致流程如下： 1234567891011121314151617181920+--------------------------------+| NTQQ 登录 QQ |+--------------------------------+ ↓+--------------------------------+| Napcat 挂在 QQ 上对外暴露接口 |+--------------------------------+ ↓+--------------------------------+| Koishi 启动 |+--------------------------------+ ↓+--------------------------------+| Koishi 通过适配器连接 Napcat |+--------------------------------+ ↓+--------------------------------+| 在 Koishi 写业务插件 |+--------------------------------+ 之后会围绕此点，一步步说明如何操作。 在执行操作前请确认服务器内各种工具的存在状态，可跳转其它博客文章确认本机内的所需依赖。 一、准备工作在当前用户目录下，执行下列命令 1234mkdir -p qqbot/napcat/configmkdir -p qqbot/napcat/datamkdir -p qqbot/koishicd ~/qqbot 在本地创建一个 docker-compose.yml 来定义这两个服务，直接扔进去或者 nano 一个，yml内容如下： 12345678910111213141516171819202122232425262728293031services: # 服务1: NapCat (QQ客户端) napcat: image: mlikiowa/napcat-docker:latest container_name: napcat restart: always # 加这两个参数防止卡死 security_opt: - seccomp:unconfined environment: - WEBUI_TOKEN=（你的密码你的密码你的密码你的密码你的密码你的密码） # NapCat管理面板的密码，请自行修改 - QQ_APP_ARGS=--no-sandbox volumes: # 映射到你要求的目录 - ./napcat/data:/app/.config/QQ - ./napcat/config:/app/napcat/config ports: - &quot;6099:6099&quot; # NapCat WebUI 端口 # 3001 端口 Koishi 会通过内部网络连接它，这样更安全 # 服务2: Koishi (机器人框架) koishi: image: koishijs/koishi container_name: koishi restart: always volumes: - ./koishi:/koishi ports: - &quot;5140:5140&quot; # Koishi 管理面板端口 depends_on: - napcat # 确保 NapCat 先启动 放进去以后，在 ~/qqbot 下执行下列操作： 1sudo docker compose up -d 二、配置 Koishi如果不是 root 用户，就赋权 1. 进入Koishi web 后台加入 auth现在服务器的 Koishi 是裸奔状态，打开浏览器访问 http://（ip地址ip地址ip地址）:5140 ，从左边的侧边栏内的依赖管理中进入依赖，修改 @koishijs/plugin-auth ，如果操作列无法点击，就刷新一下。 配置账号密码和各种参数，点击保存和应用，然后再进入主页。 这里会多出一个登录，且之前默认开放的左边侧边栏的各种选项都被隐藏，说明设置完毕。 修复可能遇到的问题 前端可能会报错，是因为 console 这个插件缺少子依赖，将其更新后应用就行 三、登录 NapCatOK 以后，打开浏览器访问 http://（ip地址ip地址ip地址）:6099/webui/ ，加载好以后差不多长这样： 输入刚刚放到 yml 里的 token，选择扫码登录或者快速登录都行，如果能在猫猫日志里看到 log，那 NapCat 就算初步完毕了。 可能会被风控，如果被风控就 sudo docker restart napcat 四、集成两者集成文档不多赘述，直接看 NapCat官方文档 配置完了 Koishi 以后，回到 NapCat ，打开网络配置添加如下 成功后，向机器人发送 help ，有回应就算完成了。","tags":["QQ机器人","Linux","napcat","koishi"],"categories":["开发日常"]},{"title":"从零开始搭建服务器--2谷歌认证","path":"/2025/11/04/从零开始搭建服务器--2谷歌认证/","content":"一、创建新用户为了错配导致 root 锁死，导致再也无法登录服务器导致报废，务必先创建一个拥有 root 权限的新用户。 12345678910111213# 1. abcdefg 处改为任意指定用户名adduser abcdefg# 2. 给刚刚的用户追加 sudo 和 docker 权限usermod -aG sudo abcdefgusermod -aG docker abcdefg# 3. 切过去，看一下此用户状态su - abcdefgidgroupssudo whoami 正常输出 root，说明新建用户成功。 在你 adduser deploy 的时候，Ubuntu 会一口气问一堆东西： 12345Full Name []:Room Number []:Work Phone []:Home Phone []:Other []: 这些统统都是写进用户信息里的“说明文字”，属于 GECOS 字段，给人看的，不是给系统用的。反复回车跳过就好。 二、给 root 用户安装 Google Authenticator PAM切回 root 直接安装。 12su - rootapt install -y libpam-google-authenticator 执行命令。 1google-authenticator 之后会蹦出来一个二维码，用 Google Authenticator 扫一下。然后会一堆问题，全部 y 就好。 做完了去编辑 /etc/pam.d/sshd，追加下列设置在其它 auth 行之前。 1auth required pam_google_authenticator.so nullok 然后编辑 /etc/ssh/sshd_config，确保（或者追加&#x2F;修改）以下几行存在且为 yes，如果行前有 # 号，把 # 去掉： 1234UsePAM yesKbdInteractiveAuthentication yes# 有的版本叫 ChallengeResponseAuthenticationChallengeResponseAuthentication yes 全部做好了以后，重载一下。 1systemctl reload sshd 或者： 1systemctl restart sshd 做完了以后，去将 root 用户的登录认证改为 Keyboard Interactive，我使用的是 Xshell。 登录后会弹窗让你输入验证码，输入就能登录成功。","tags":["Linux","云服务器","web"],"categories":["开发日常"]},{"title":"从零开始搭建服务器--1安装各种环境","path":"/2025/11/04/从零开始搭建服务器--1安装各种环境/","content":"一、基础系统 &amp; 安全基线 &amp; 常用工具我个人使用的操作系统是 Ubuntu 24 ，以下各种命令可以直接复制运行。 1234567891011121314151617181920212223242526272829303132333435# 0. 更新系统apt updateapt -y upgrade# 1. 设置时区为日本（你后面定时任务都按这个）timedatectl set-timezone Asia/Shanghai# 2. 安装常用工具apt -y install \\ ca-certificates \\ curl wget \\ git \\ htop \\ unzip zip \\ vim \\ net-tools \\ lsof \\ ufw \\ fail2ban \\ gnupg \\ lsb-release# 3. 基础防火墙：放行 SSH / HTTP / HTTPSufw allow OpenSSHufw allow 80/tcpufw allow 443/tcpufw --force enable# 4. 可选：创建 2G swap（建议做上，防止偶尔 OOM）fallocate -l 2G /swapfilechmod 600 /swapfilemkswap /swapfileecho &#x27;/swapfile none swap sw 0 0&#x27; | tee -a /etc/fstabswapon -a 二、Java 17 + MySQL + Docker &#x2F; Compose + 日志控制做 Java Web 服务，将最小的必要依赖安装好。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960######################################### 1. 安装 Java 17 + Maven########################################apt -y install openjdk-17-jdk-headless maven# 检查一下java -versionmvn -v# 2. 安装 MySQL Server 8apt -y install mysql-server# 启动并设为开机自启（一般默认就是启用的）systemctl enable --now mysql# 运行基础安全向导# 建议：设置 root 密码、禁用远程 root 登录、删除匿名用户、删除测试库mysql_secure_installation# 3. 安装 Docker 引擎（官方脚本）curl -fsSL https://get.docker.com | sh# 将当前用户 root 加入 docker 组usermod -aG docker root || true# 创建 Docker 数据目录，并设置 data-root + 日志限制mkdir -p /srv/dockermkdir -p /etc/dockercat &gt;/etc/docker/daemon.json &lt;&lt;&#x27;JSON&#x27;&#123; &quot;data-root&quot;: &quot;/srv/docker&quot;, &quot;log-driver&quot;: &quot;json-file&quot;, &quot;log-opts&quot;: &#123; &quot;max-size&quot;: &quot;10m&quot;, &quot;max-file&quot;: &quot;3&quot; &#125;&#125;JSONsystemctl daemon-reloadsystemctl restart docker# 4. 安装 docker compose 插件（使用 docker compose 命令）apt -y install docker-compose-plugin# 简单自检一下 Dockerdocker version || echo &quot;Docker 有问题，后面我们再查&quot;docker compose version || echo &quot;docker compose 插件有问题&quot;# 5. 限制 systemd 日志占用mkdir -p /etc/systemd/journald.conf.dcat &gt;/etc/systemd/journald.conf.d/size.conf &lt;&lt;&#x27;CONF&#x27;[Journal]SystemMaxUse=200MSystemMaxFileSize=50MCONFsystemctl restart systemd-journald 三、检查服务器各种情况执行完后可直接扔给 AI 帮忙评估。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105echo &quot;==================== 1. 基本 OS / 内核信息 ====================&quot;uname -aecholsb_release -a 2&gt;/dev/null || cat /etc/os-releaseechohostnamectlechoecho &quot;当前时间与时区：&quot;datetimedatectlechoecho &quot;开机时长：&quot;uptimeechoecho &quot;==================== 2. CPU 信息 ====================&quot;lscpuechoecho &quot;逻辑 CPU 个数：&quot;nproc --allechoecho &quot;==================== 3. 内存信息 ====================&quot;free -hechoecho &quot;详细 /proc/meminfo（前 20 行）：&quot;head -n 20 /proc/meminfoechoecho &quot;==================== 4. 磁盘与文件系统 ====================&quot;echo &quot;块设备与分区：&quot;lsblk -fechoecho &quot;挂载点与使用率：&quot;df -hTechoecho &quot;inode 使用情况：&quot;df -iechoecho &quot;分区详细信息（需要 sudo）：&quot;sudo fdisk -l 2&gt;/dev/null || echo &quot;fdisk -l 运行失败（可能权限不足或无传统磁盘）&quot;echoecho &quot;==================== 5. 硬件 / 虚拟化信息 ====================&quot;echo &quot;虚拟化检测：&quot;systemd-detect-virtechoecho &quot;简要硬件信息（需要 sudo，可能稍微等几秒）：&quot;sudo lshw -short 2&gt;/dev/null || echo &quot;lshw 未安装或权限不足，可用: sudo apt install lshw&quot;echoecho &quot;PCI 设备（比如网卡、存储控制器）：&quot;lspci 2&gt;/dev/null || echo &quot;lspci 未安装，可用: sudo apt install pciutils&quot;echoecho &quot;USB 设备：&quot;lsusb 2&gt;/dev/null || echo &quot;lsusb 未安装，可用: sudo apt install usbutils&quot;echoecho &quot;==================== 6. 网络信息 ====================&quot;echo &quot;网卡与 IP：&quot;ip addrechoecho &quot;路由表：&quot;ip routeechoecho &quot;监听的端口（当前应该几乎为空）：&quot;ss -tulpenechoecho &quot;==================== 7. 进程与资源占用快照 ====================&quot;echo &quot;前 15 个最吃 CPU 的进程：&quot;ps aux --sort=-%cpu | head -n 15echoecho &quot;前 15 个最吃内存的进程：&quot;ps aux --sort=-%mem | head -n 15echoecho &quot;==================== 8. 日志与系统健康快照 ====================&quot;echo &quot;最近 50 行系统日志：&quot;sudo journalctl -n 50 --no-pager 2&gt;/dev/null || echo &quot;journalctl 命令失败（可能权限不足）&quot;echoecho &quot;==================== 9. 已安装的关键软件（docker 等） ====================&quot;echo &quot;Docker 版本：&quot;docker --version 2&gt;/dev/null || echo &quot;docker 尚未安装&quot;echoecho &quot;Java 版本：&quot;java -version 2&gt;&amp;1 || echo &quot;java 尚未安装&quot;echoecho &quot;MySQL 客户端：&quot;mysql --version 2&gt;/dev/null || echo &quot;mysql 客户端尚未安装&quot;echoecho &quot;==================== 10. 磁盘 I/O 与文件描述符限制 ====================&quot;echo &quot;磁盘 I/O 调度与队列：&quot;cat /sys/block/*/queue/scheduler 2&gt;/dev/null || echo &quot;无法读取磁盘 I/O 调度器信息（可能是云盘虚拟设备）&quot;echoecho &quot;当前用户的文件句柄限制：&quot;ulimit -nechoecho &quot;系统级最大文件句柄数：&quot;cat /proc/sys/fs/file-max","tags":["Linux","云服务器","web"],"categories":["开发日常"]},{"title":"bsdx逆向--2mek的机体信息","path":"/2025/09/03/bsdx逆向--2mek的机体信息/","content":".mek 文件按照顺序结构，大致可以从上至下分为 12345671 头部偏移2 机体本体信息3 spm序列信息4 武装信息5 ai信息6 疑似voice信息7 武装素材组清单 本次主要记录的是其中的 2 机体本体信息，会记录从如何发现规律，到实现思路的全过程。 1.观察二进制使用任意一款二进制查看工具，将字符集调整到日语，我这里使用的是 010 Editor 。 [p1] 看到开头处一定不会觉得陌生，因为这里明显就是每个机体的基本信息。并且是以 00 为字符串的结尾符。其开头的 01 00 00 00 则是存在 FLAG，用于给 NeXAS 引擎判断下一个块是否存在，不存在会直接 return 。 那么，其组成大致就可按直觉表述为 1234567891011121314class Weapon &#123; // 机体名 String mekName; // 机体名EN String mekNameEnglish; // 驾驶员名字 String pilotNameKanji; // 驾驶员名字EN String pilotNameRoma; // 机体描述文本 String mekDescription; // 一连串的小端整型数，数据块 List&lt;Integer&gt; leInts;&#125; 其下方的数据块均为小端整型，4 字节的数据。 观察别的 .mek 文件，会发现均为相同特征，且 leInts 的大小均完全相等，说明此 part 并不存在运行时的动态读取，而是以固定的顺序依次加载并使用。 [p2] 2.反编译静态分析若上述结论正确，其特征应该也能在各种反编译工具中轻易找到，这里使用 IDA pro 进行静态分析。 寻找逻辑的方向就是直接全局搜索 .mek 字符串，并在使用到该字符串的周围，以及其下方的部分函数中，寻找是否有连续的字符串读取和连续的数值读取。（当然，你首先要能看出哪个函数是从流里读出数据的） 果不其然，在其中一个 .mek 字符串被引用到的，下方的一个函数中，能找到与二进制排布顺序完全一致的线性读取逻辑。 [p3] 此外，还能发现很多明显是用于开发的日语字符串，这里也被封到游戏 exe 里了，不过后续通过 resource hacker 发现，此处其实是 devtools 的 ui 里的文字。 [p4][p5] 那么，剩下的就简单了，对于任何一个玩这游戏好几百小时的人来说，估计看到数值就能猜个八九不离十，轻易找出机体信息内各种数值的含义，哪怕不知道，稍微改改封回去，也能立马悟到。 其实现如下： parseMekInfo方法为真实实现","tags":["逆向工程","二进制编辑","开发","mod","BALDR SKY DiveX","IDA pro","mek"],"categories":["开发日常","逆向工程","mod"]},{"title":"关于发博客的工作流","path":"/2025/09/03/关于发博客的工作流/","content":"本人使用 hexo + Stellar + github pages，搭建博客，为了方便以后，记录下整个工作流和命令。 1.博客的撰写这个没什么好说的，直接在 source/_posts 下新建 .md 然后写就完事了，如果要插入图片的话，在该目录下自己建一个就好。 2.发布的流程写好文章以后，直接预览。 1hexo s 没问题就 1hexo d -g 有问题就 12hexo cleanhexo g 如此简单。 3.意外情况如果deploy的时候发现git在报错，说明之前不小心把 .deploy_git 也传上去了，记得删一下就行。","tags":["hexo","Stellar"],"categories":["博客"]},{"title":"bsdx逆向--1确认mek结构","path":"/2025/01/18/bsdx逆向--1确认mek结构/","content":"第一天正式开始逆向，已经确定大体结构，记录下逆向反序列化 .mek 文件的思路。 1.确定大块在bsdx中的 .mek 文件的它们大概率用的是同一套解析逻辑，意味着可以将其规律整合抽象为类，统一反序列化。 其中根据群友二进制编辑后整合的结论来看，不难得出以下对于大块规律的结论。 ①区块大小块第一个块固定为24字节，因为是32位游戏程序，所以读取方式为小端序有符号整型，以 Aki.mek 为例，以下为第一块的hex形式字符 1200000000 18 00 00 00 7F 01 00 00 EF 01 00 00 EB 0B 00 0000000010 B2 28 00 00 D3 2A 00 00 数值分别为 24 383 495 3051 10418 10963 将其简单分别称为 序列1 序列2 序列3 序列4 序列5 序列6 先说结论， 序列1为从起始位置读起的区块大小块总字节 序列2为从起始位置读起的区块大小块+机体信息总字节 序列3为从起始位置读起的区块大小块+机体信息+未知信息1总字节 序列4为从起始位置读起的区块大小块+机体信息+未知信息1+武装信息总字节 序列5为从起始位置读起的**区块大小块+机体信息+未知信息1+武装信息+AI信息1(?)**总字节 序列6为从起始位置读起的**区块大小块+机体信息+未知信息1+武装信息+AI信息1(?)+AI信息2(?)**总字节 所以不难看出，每块的字节数，也就是长度，可由序列递减得出。 ②机体信息块序列2-序列1=359，则为该块大小，取对应的字节序列如下 123456789101112131415161718192021222300000010 83 56 83 8B 83 74 83 4000000020 00 53 49 4C 50 48 41 00 90 BC 96 EC 20 88 9F 8B00000030 47 00 41 4B 49 20 4E 49 53 48 49 4E 4F 00 88 9F00000040 8B 47 82 AA 8B 43 82 DC 82 AE 82 EA 82 C5 82 6300000050 82 6B 82 B5 82 BD 83 56 83 85 83 7E 83 4E 83 8900000060 83 80 81 42 82 E2 82 CD 82 E8 8E A9 8E D0 82 CC00000070 90 BB 95 69 82 AA 8D 44 82 DD 81 42 83 8A 83 4100000080 83 8B 82 E6 82 E8 89 BC 91 7A 82 C6 82 CC 91 8A00000090 90 AB 82 AA 97 C7 82 A2 88 9F 8B 47 82 CD 88 D3000000A0 8A 4F 82 C6 8F E6 82 E8 82 B1 82 C8 82 B9 82 C4000000B0 82 A2 82 E9 82 E6 82 A4 82 C5 82 B7 81 42 90 AB000000C0 94 5C 93 49 82 C9 82 CD 83 56 83 8B 83 74 83 40000000D0 82 C6 82 D9 82 C6 82 F1 82 C7 95 CF 82 ED 82 E7000000E0 82 C8 82 A2 82 C5 82 B7 82 AA 91 E5 97 CA 82 C9000000F0 83 7A 81 5B 83 7E 83 93 83 4F 83 8C 81 5B 83 5500000100 81 5B 82 F0 95 FA 82 C2 83 74 83 48 81 5B 83 5800000110 83 4E 83 89 83 62 83 56 83 85 82 AA 8E 67 82 A600000120 82 DC 82 B7 81 42 00 10 00 00 00 26 00 00 00 0E00000130 00 00 00 1E 00 00 00 41 00 00 00 64 00 00 00 0000000140 00 00 00 06 00 00 00 00 00 00 00 04 00 00 00 0000000150 00 00 00 C8 00 00 00 02 00 00 00 04 00 00 00 0300000160 00 00 00 03 00 00 00 00 00 00 00 02 00 00 00 0500000170 00 00 00 09 00 00 00 09 00 00 00 00 00 00 00 遗憾的是本人还未发现具体规律以及数值的意义，但可以确定的是，数据是以文本信息(Shift-JIS)+数据信息的顺序排列。 ③未知信息1序列3-序列2=112，则为该块大小，取对应的字节序列如下 1234567800000170 FF00000180 FF FF FF 00 00 00 00 FF FF FF FF 01 00 00 00 FF00000190 FF FF FF 01 00 00 00 FF FF FF FF FF FF FF FF FF000001A0 FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF000001B0 FF FF FF 02 00 00 00 FF FF FF FF 03 00 00 00 FF000001C0 FF FF FF 04 00 00 00 FF FF FF FF 05 00 00 00 FF000001D0 FF FF FF 06 00 00 00 FF FF FF FF 07 00 00 00 FF000001E0 FF FF FF 08 00 00 00 FF FF FF FF 09 00 00 00 所以这里面到底是啥呢? ④武装信息序列4-序列3=2556，则为该块大小，取对应的字节序列如下 12345678910111213141516171819000001E0 0B000001F0 00 00 00 01 00 00 00 83 6F 83 8C 83 8B 83 58 8300000200 5E 83 93 83 76 00 30 30 30 31 00 8F 65 8F B0 8200000210 C5 89 A3 82 E8 82 C2 82 AF 82 C4 8D 55 8C 82 8200000220 B5 82 DC 82 B7 81 42 83 7B 83 5E 83 93 82 F0 8900000230 9F 82 B5 82 C1 82 CF 82 C8 82 B5 82 C9 82 B7 8200000240 E9 8E 96 82 C5 8D C5 91 E5 82 52 89 F1 89 A3 8200000250 E9 8E 96 82 AA 82 C5 82 AB 82 DC 82 B7 81 42 0000000260 FF FF FF FF 0A 00 00 00 00 00 00 00 0A 00 00 0000000270 00 00 00 00 00 00 00 00 3C 00 00 00 00 00 00 0000000280 00 00 00 00 00 00 00 00 0A 00 00 00 00 00 00 0000000290 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00000002A0 00 00 00 00 00 00 00 00 01 00 00 00 01 00 00 00。。。。00000BA0 FF FF FF 14 00 00 00 00 00 00 00 01 00 00 00 0000000BB0 00 00 00 00 00 00 00 32 00 00 00 02 00 00 00 0000000BC0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0000000BD0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0000000BE0 00 00 00 00 00 00 00 01 00 00 00 开头的第一个int值为武装的总数量，比如这里aki，写着有11个。但是进游戏一看，只有10个武装啊！原因是……还是下次再写吧。然后剩下的便是武装列表的各种武装，其具体数值对应的意义后续再研究。 ⑤AI信息1(?)⑥AI信息2(?)两者大概率为同样的ai信息，并不打算逆向此部分，因此放弃研究，值得注意的是这两个块的头部分别有一个或两个数值，代表着什么呢？","tags":["逆向工程","二进制编辑","java","开发","mod"],"categories":["开发日常","逆向工程","mod"]},{"title":"创建electron+vue项目","path":"/2025/01/05/vue桌面应用开发/","content":"步骤1：初始化vite项目打开命令行，到目标目录下输入以下命令 1npm create vite@latest 会提示你输入你要创建的项目文件夹 123456D:\\Code\\java\\NeXAS_DX&gt;npm create vite@latest&gt; npx&gt; create-vite? Project name: » frontend 选择Others 123456789101112√ Project name: ... frontend? Select a framework: » - Use arrow-keys. Return to submit. Vanilla Vue React Preact Lit Svelte Solid Qwik Angular&gt; Others 然后选择 create-electron-vite 12345√ Project name: ... frontend√ Select a framework: » Others? Select a variant: » - Use arrow-keys. Return to submit. create-vite-extra ↗&gt; create-electron-vite ↗ 然后选择 Vue 1234567&gt; npx&gt; create-electron-vite frontend? Project template: » - Use arrow-keys. Return to submit.&gt; Vue React Vanilla 有下列提示则代表初始化完成 12345Done. Now run: cd frontend npm install npm run dev 如上提示按顺序执行，弹窗弹出一个GUI，则代表项目构建结束 步骤2：调整配置打开你的IDE，并找到 electron-builder.json5 ，如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344// @see - https://www.electron.build/configuration/configuration&#123; &quot;$schema&quot;: &quot;https://raw.githubusercontent.com/electron-userland/electron-builder/master/packages/app-builder-lib/scheme.json&quot;, &quot;appId&quot;: &quot;YourAppID&quot;, &quot;asar&quot;: true, &quot;productName&quot;: &quot;YourAppName&quot;, &quot;directories&quot;: &#123; &quot;output&quot;: &quot;release/$&#123;version&#125;&quot; &#125;, &quot;files&quot;: [ &quot;dist&quot;, &quot;dist-electron&quot; ], &quot;mac&quot;: &#123; &quot;target&quot;: [ &quot;dmg&quot; ], &quot;artifactName&quot;: &quot;$&#123;productName&#125;-Mac-$&#123;version&#125;-Installer.$&#123;ext&#125;&quot; &#125;, &quot;win&quot;: &#123; &quot;target&quot;: [ &#123; &quot;target&quot;: &quot;nsis&quot;, &quot;arch&quot;: [ &quot;x64&quot; ] &#125; ], &quot;artifactName&quot;: &quot;$&#123;productName&#125;-Windows-$&#123;version&#125;-Setup.$&#123;ext&#125;&quot; &#125;, &quot;nsis&quot;: &#123; &quot;oneClick&quot;: false, &quot;perMachine&quot;: false, &quot;allowToChangeInstallationDirectory&quot;: true, &quot;deleteAppDataOnUninstall&quot;: false &#125;, &quot;linux&quot;: &#123; &quot;target&quot;: [ &quot;AppImage&quot; ], &quot;artifactName&quot;: &quot;$&#123;productName&#125;-Linux-$&#123;version&#125;.$&#123;ext&#125;&quot; &#125;&#125; 将其改成如下 1234567891011121314151617181920212223242526&#123; &quot;productName&quot;: &quot;nexasdxeditor&quot;, &quot;appId&quot;: &quot;com.nexasdxeditor.www&quot;, &quot;win&quot;: &#123; &quot;icon&quot;: &quot;electron/resource/images/head.png&quot;, &quot;target&quot;: [ &#123; &quot;target&quot;: &quot;nsis&quot;, &quot;arch&quot;: [&quot;x64&quot;] &#125; ] &#125;, &quot;nsis&quot;: &#123; &quot;oneClick&quot;: false, &quot;perMachine&quot;: true, &quot;allowToChangeInstallationDirectory&quot;: true &#125;, &quot;files&quot;: [ &quot;dist&quot;, &quot;dist-electron&quot; ], &quot;directories&quot;: &#123; &quot;output&quot;: &quot;build&quot; &#125;&#125; 然后在 electron 文件夹下创建 resource/images/head.png ，创建完成后，找到 main.js 并将一部分代码注释掉 1234567import &#123; app, BrowserWindow &#125; from &#x27;electron&#x27;// import &#123; createRequire &#125; from &#x27;node:module&#x27;import &#123; fileURLToPath &#125; from &#x27;node:url&#x27;import path from &#x27;node:path&#x27;// const require = createRequire(import.meta.url)const __dirname = path.dirname(fileURLToPath(import.meta.url)) 注释后重新在命令行构建 1npm run build 如果是初次执行，会下载一堆依赖，因为都是从github上下载的，所以……还是请自行解决。 总之，完成以后会是这样 12345678910111213141516171819202122232425262728293031323334353637D:\\Code\\java\\NeXAS_DX\\frontend&gt;npm run build&gt; frontend@0.0.0 build&gt; vue-tsc &amp;&amp; vite build &amp;&amp; electron-buildervite v5.4.11 building for production...✓ 18 modules transformed.dist/index.html 0.48 kB │ gzip: 0.31 kBdist/assets/index-BKCeV6hx.css 1.27 kB │ gzip: 0.65 kBdist/assets/index-CVTRloTz.js 60.87 kB │ gzip: 24.57 kB✓ built in 388msvite v5.4.11 building for production...✓ 1 modules transformed.dist-electron/main.js 1.08 kB │ gzip: 0.59 kB✓ built in 9msvite v5.4.11 building for production...✓ 1 modules transformed.dist-electron/preload.mjs 0.35 kB │ gzip: 0.18 kB✓ built in 9ms • electron-builder version=24.13.3 os=10.0.22631 • loaded configuration file=D:\\Code\\java\\NeXAS_DX\\frontend\\electron-builder.json5 • description is missed in the package.json appPackageFile=D:\\Code\\java\\NeXAS_DX\\frontend\\package.json • author is missed in the package.json appPackageFile=D:\\Code\\java\\NeXAS_DX\\frontend\\package.json • writing effective config file=build\\builder-effective-config.yaml • packaging platform=win32 arch=x64 electron=30.5.1 appOutDir=build\\win-unpacked • downloading url=https://github.com/electron/electron/releases/download/v30.5.1/electron-v30.5.1-win32-x64.zip size=109 MB parts=8 • downloaded url=https://github.com/electron/electron/releases/download/v30.5.1/electron-v30.5.1-win32-x64.zip duration=10.801s • downloading url=https://github.com/electron-userland/electron-builder-binaries/releases/download/winCodeSign-2.6.0/winCodeSign-2.6.0.7z size=5.6 MB parts=1 • downloaded url=https://github.com/electron-userland/electron-builder-binaries/releases/download/winCodeSign-2.6.0/winCodeSign-2.6.0.7z duration=49.155s • building target=nsis file=build exasdxeditor Setup 0.0.0.exe archs=x64 oneClick=false perMachine=true • downloading url=https://github.com/electron-userland/electron-builder-binaries/releases/download/nsis-3.0.4.1/nsis-3.0.4.1.7z size=1.3 MB parts=1 • downloaded url=https://github.com/electron-userland/electron-builder-binaries/releases/download/nsis-3.0.4.1/nsis-3.0.4.1.7z duration=36.725s • downloading url=https://github.com/electron-userland/electron-builder-binaries/releases/download/nsis-resources-3.4.1/nsis-resources-3.4.1.7z size=731 kB parts=1 • downloaded url=https://github.com/electron-userland/electron-builder-binaries/releases/download/nsis-resources-3.4.1/nsis-resources-3.4.1.7z duration=1m14.848s • building block map blockMapFile=build exasdxeditor Setup 0.0.0.exe.blockmapD:\\Code\\java\\NeXAS_DX\\frontend&gt; 最后一步，找到你的 build\\win-unpacked 双击exe启动 外面的那个则是安装包，如果你做的是开源项目，可以放到release目录下供大家使用 结语最近打算给一款名为 baldr sky divex 的游戏开发一款mod编辑器，但无奈的是本人没有桌面应用开发经验。 索性知道了还有个Electron能直接以前端技术栈进行GUI的开发，并且可以连带启动子程序打包，意思就是我只用画个画面，然后写个后端就能给大家使用了（虽然现在的功能只有打包解包与shift-jis转hex）。 项目如下，如果有兴趣的话可以看看臃肿的代码： https://github.com/Karaik/NeXAS_DX 目前（2025&#x2F;01&#x2F;05）这个项目还是私有项目，因为啥也没做出来，之后有成果的话会开源。","tags":["electron","vue","vite","桌面应用开发"],"categories":["开发日常"]},{"title":"博客测试","path":"/2024/12/27/example/","content":"一级标题删除线 加粗","tags":["博客","github","hexo","技术"],"categories":["博客","github","hexo","技术"]}]